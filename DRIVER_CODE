/*
 * Motor_Driver_Code.c
 *
 * Created: 6/19/2015 10:11:52 PM
 *  Author: Kevin Mak
 */ 

/*
	IN1	|	IN2	|	Operation
	-------------------------
	L	|	L	|	CW
	-------------------------
	L	|	H	|	CCW
	-------------------------
	H	|	L	|	Brake
*/

/* Motor 1 = IN1 = 1
	     IN2 = 3
   Motor 2 = IN1 = 2
             IN2 = 4
*/

//Equation for waveform frequency

/*
	[F(OCnx)] = [F(clk_I/O)] / [2*N*(1+OCRnx)]        We Chose N = 256
*/
#define F_CPU 14745600UL
#include <avr/io.h>
#include <avr/interrupt.h>
#include <stdio.h>
#include <stdlib.h>
#include <util/delay.h>

void motor_BRAKE();
void motor_FWD();
void motor_BWD();
void motor_R_TURN();
void motor_L_TURN();

void motorL_CW();
void motorR_CW();

void motorL_CCW();
void motorR_CCW();

void _pwm_init();


/*ISR(TIMER0_COMPA_vect){
	
	TCNT0 = 0;
	
}*/
 
 
//MAIN CODE 
int main(void)
{
	//init_uart();
	//prinf_P(PSTR("System Booted, built %s on %s\n"), __TIME__, __DATE__);

	//PORTD is all inputs, pull-ups enabled
	DDRD = 0;								// enabling port d for inputs
	PORTD = 0xFF;							//pull-ups enabled i.e. they are all 1 and will stay as so until a external force makes it zero (connect to ground)
	
	//PORTB outputs
	DDRB |=  _BV(0) | _BV(1) | _BV(2) | _BV(3) | _BV(4);				
		
	
	//_pwm_init();
	//_delay_ms(2000);
	
	motor_FWD();	
	_delay_ms(2000);
	
	//motor_BWD();
	//_delay_ms(2000);
	
	//motor_BRAKE();
	//_delay_ms(500);
}

//PWM SQUARE WAVE to port B pin 3,4
/*void _pwm_init()
{	
	DDRB |= _BV(3) | _BV(4);							//BRAKE INITIALLY
	OCR0A = 128;
	OCR0B = 128;
	
	TCCR0A |= _BV(COM0A1) | _BV(COM0A0) | _BV(WGM00) | _BV(COM0B1) | _BV(COM0B0);	
	TCCR0B = 1<<CS00;
}*/

//BRAKE
void motor_BRAKE()
{
	PORTB &= (~(_BV(1) | _BV(2)));
	PORTB ^= (_BV(3) | _BV(4));
	
	//PORTB &= (~(_BV(0) | _BV(2)));
	//PORTB ^= (_BV(1) | _BV(3));	
}

//FORWARDS
void motor_FWD()
{
	motor_BRAKE();
	_delay_ms(500);
	
	motorL_CW();
	motorR_CW();
	//PORTB ^= (_BV(0) | _BV(1) | _BV(2) | _BV(3));
}

//BACKWARDS
void motor_BWD()
{	
	motor_BRAKE();
	_delay_ms(500);
	
	motorR_CCW();
	motorL_CCW();
		
	//PORTB ^= (_BV(0) | _BV(2));
	//PORTB &= (~(_BV(1) | _BV(3)));
}

//LEFT TURN
void motor_L_TURN()
{
	motor_BRAKE();
	_delay_ms(500);
	motorR_CW();
	motorL_CCW();
}

//RIGHT TURN
void motor_R_TURN()
{	
	motor_BRAKE();
	_delay_ms(500);
	motorR_CCW();
	motorL_CW();
}

//RIGHT MOTOR CW
 void motorR_CW()
 {
	 PORTB = 0x00;
	 PORTB ^= (_BV(3) | _BV(1));
 }
 
//LEFT MOTOR CCW
 void motorL_CW()
 {
	 PORTB = 0X00;
	 PORTB ^= (_BV(4) | _BV(2));
 }
 
//RIGHT MOTOR CCW 
 void motorR_CCW()
 {
	 PORTB = 0x00;
	 PORTB ^= (_BV(1));
 }
 
//LEFT MOTOR CW
 void motorL_CCW()
 {
	 PORTB = 0x00;
	 PORTB ^= (_BV(2));
 }

/*if ((PIND & (_BV(0)|_BV(1))) == 0){
	PORTB ^= (_BV(0) | _BV(1) | _BV(2) | _BV(3));			//CW				Xor port B (toggles output)
	//explicitly turn off BV0
	//PORTB ^= _BV(1);
	}else if (((PIND & _BV(0)) == 1) && (PIND & _BV(1) == 0)){							//CCW
	
	PORTB ^= (_BV(0) | _BV(2));
	PORTB &= (~(_BV(1) | _BV(3)));
	
	}else if (((PIND & _BV(1)) == 1) && (PIND & _BV(0) == 0)){							//BRAKE				turn on BV1 and BV3
	
	PORTB &= (~(_BV(0) | _BV(2)));
	PORTB ^= (_BV(1) | _BV(3));
	
	}else if ((PIND & (_BV(0)|_BV(1))) == 1){					// if open then BRAKE
	
	PORTB ^= (_BV(0) | _BV(2));
	PORTB &= (~(_BV(1) | _BV(3)));
}*/

